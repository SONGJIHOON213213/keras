import numpy as np 
from tensorflow.python.keras import Sequential
from tensorflow.python.keras.layers import Dense

# 1 데이터
x = np.array([1,2,3])
y = np.array([1,2,3])

#2. 모델구성
model = Sequential()
model.add(Dense(5, input_dim=1))
model.add(Dense(4))
model.add(Dense(3))
model.add(Dense(2))
model.add(Dense(1))

model.summary()
 _________________________________________________________________
# Layer (type)                 Output Shape 아웃풋             Param # 파타미터 #연산할떄바이어스까지포함해서 값이 나온다
# =================================================================
# dense (Dense)                (None, 5)1,5                 10
# _________________________________________________________________
# dense_1 (Dense)              (None, 4)1,4                 24
# _________________________________________________________________
# dense_2 (Dense)              (None, 3)1,3                 15
# _________________________________________________________________
# _________________________________________________________________
# dense_4 (Dense)              (None, 1)1,1                 3
# ================================================================= #상관없다 None

# nomalraization = 보통 
# 스케일링은 모두 x에만 해당 
# 정규화라는것은 게속 연산되는 x를 과부화되지않게 해주는 역활
# 정규화는 변경했을대도 동일한 값으로 변경되어짐
# 정규화 단점 
# x-min,    x-10
# -------  -----
# max-min   100-10
# 훈련데이터만 정규화한다
# x-train  0-100까지가 빠졋다 (80개) 0~1 #정규화는 처음실행한룰대로 해야된다
# X_test   80-110 (20개) 0~1 0.8~1.1
# 전체데이터를 정규하하면 과적화 되버려서 나중에 안맞는다 과적화를 막기위해 정규화
# 내가 예측한 범위 밖을 연결시켜주는게 과적화방지에 도움
# 1.트레인 데이터 잡는다
# 2.범위에 비율에 맞춰서 변환
# 3.0이하면 그게 오히려 더좋다 0~1사이로 꽉맞처버리면 테스트에서 좋게나오므로 안좋다
# 훈련데이터만 정규화 비율은 0~1사이 나머지 테스트 데이터를 정규화 그 정규화는 트레인 데이터 비율에 맞춰서
# 트레인 테스트 분리후에 스케일링
# 
#
#
#
#
#
